As a researcher, quite often you want to find related malware samples to a sample you have. The way to do this is to pivot from existing data, and some of the techniques to do this are written below. In my opinion, the most comprehensive way to pivot is to use all of these methods when permissible. Attackers change their methods over time, but it is less likely that they change all the methods on which we can pivot from at the same time. Of course, remember that every one of these can be faked.

# Pivot on strings
This is the most common way of pivoting - find a bunch of strings which seem unique to an executable, and try to find other executables which have those strings. However, it completely fails on packed/protected executables.

# Pivot on imphash
Mandiant/FireEye formalized the use of the imphash, which is a hash of the executable's import hash table. This is fairly accurate because not only does it match all import function names, but the order of functions / apis used in the source code also changes the imphash.

# Pivot on compilation timestamp
Since the time that an executable is compiled is saved down to the second, there will not be too many matches for a particular time usually. However, this technique does not find related samples but rather the same sample. The reason is that there are tools which modify a particular sample - for example, packing, protecting, removing identifiable information, etc. If you pivot and find the same sample before an attacker performed certain steps on the executable, we can find what they were trying to hide.

# Pivot on Imports / Exports
Unless the sample has a particularly unique export name, we will get lots of false positives here. But that is the whole point of pivoting. Sometimes you have a very unique piece of data (e.g. imphash/timestamp) which can allow us to pivot just by using that, and other times we use many pieces of data together to pivot without (or with few) false positives. 

# Pivot on PDB strings
Depending on the compiler / compiler settings used, program database information may be stored in the executable. This is meant to be used for debugging purposes, and has the added benefit of showing us the full path of where the executable was compiled, including the username of the machine.

# Pivot on RICH header
Microsoft compilers include an undocumented "RICH Header" in executables, which stores data related to the compilation environment. Not all PE viewers have the capability to view this header, but some of the newer ones such as PE Bear, PPEE, and LIEF can.

# Pivot on code signing certificate
If the executable was signed with a (usually revoked) code signing certificate, this is an easy win because there are only so many stolen certificates an attacker can find. But this one can only be used to pivot for a short while before the attacker stops using it.

# Pivot on program constants
If you can find a hidden constant used by an executable, this is a great methods to pivot on. The most common example I can think of is hardcoded encryption/obfuscation related keys. But great as it is, it's just one method and is easy for attackers to change.

# Pivot on opcodes
Opcodes are an extremely powerful way to pivot on. But the problem with this is that compiler settings, versions, etc could all potentially change the opcodes because of optimizations and other things, so it's hard to find a valid use case for pivoting on opcodes.

# Pivot on sandbox/emulation results
Some systems come with a sandbox/emulator, and you can pivot off those dynamic results as well. For example, pivoting off a hardcoded mutex name, file name, or registry key would work only when this is being executed. In my opinion if you can get a good system with these kind of capabilities, it would be the most powerful way to pivot most of the time.

# Pivot on file similarity
Some systems have their own tagging capability on what a particular executable can do. A simple example would be to tag whether the executable has anti-debugging capabilities. By tagging on hundreds or thousands of such capabilities, the system can match on other executables with similar tags.

# Pivot on filename
If we get something called install.exe or svchost.exe, there will be many matches, but otherwise filenames can be surprisingly unique.

# Pivot on nonexistence
Remember that pivoting is just as much matching using data that is there (e.g. export name = x) as it is matching using data that is **not** there (e.g. export name != y, import name != z).

# Pivot on Infrastructure
Even different kinds of malware families might use the same infrastructure. Of course, this assumes that the C2 server has not been hacked by another actor.

# Pivot on different formats
If you have a particular string, you might make a duplicate rule which searches for that string in a different format such as base64. This helps to pivot in some edge cases, such as when the file you are looking for is not in its original format (e.g. a script decodes it or it is embedded in another file type).
