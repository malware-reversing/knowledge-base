As a researcher, quite often you want to find related malware samples to a sample you have. The way to do this is to pivot from existing data, and some of the techniques to do this are written below. In my opinion, the most comprehensive way to pivot is to use all of these methods when permissible. Attackers change their methods over time, but it is less likely that they change all the methods on which we can pivot from at the same time. Of course, remember that every one of these can be faked.

# Pivot on strings
This is the most common way of pivoting - find a bunch of strings which seem unique to an executable, and try to find other executables which have those strings. However, it completely fails on packed/protected executables.

# Pivot on imphash
Mandiant/FireEye formalized the use of the imphash, which is a hash of the executable's import hash table. This is fairly accurate because not only does it match all import function names, but the order of functions / apis used in the source code also changes the imphash.

# Pivot on compilation timestamp
Since the time that an executable is compiled is saved down to the second, there will not be too many matches for a particular time usually. However, this technique does not find related samples but rather the same sample. The reason is that there are tools which modify a particular sample - for example, packing, protecting, removing identifiable information, etc. If you pivot and find the same sample before an attacker performed certain steps on the executable, we can find what they were trying to hide.

# Pivot on document creation date
As long as the author is using the same template document (common!), it will have the same document creation data metadata.

# Pivot on Imports / Exports
Unless the sample has a particularly unique export name, we will get lots of false positives here. But that is the whole point of pivoting. Sometimes you have a very unique piece of data (e.g. imphash/timestamp) which can allow us to pivot just by using that, and other times we use many pieces of data together to pivot without (or with few) false positives. 

# Pivot on PDB strings
Depending on the compiler / compiler settings used, program database information may be stored in the executable. This is meant to be used for debugging purposes, and has the added benefit of showing us the full path of where the executable was compiled, including the username of the machine.

# Pivot on RICH header
Microsoft compilers include an undocumented "RICH Header" in executables, which stores data related to the compilation environment. Not all PE viewers have the capability to view this header, but some of the newer ones such as PE Bear, PPEE, and LIEF can.
See https://github.com/malware-reversing/knowledge-base/tree/master/Pivoting%20on%20RICH

# Pivot on code signing certificate
If the executable was signed with a (usually revoked) code signing certificate, this is an easy win because there are only so many stolen certificates an attacker can find. But this one can only be used to pivot for a short while before the attacker stops using it.

# Pivot on program constants
If you can find a hidden constant used by an executable, this is a great methods to pivot on. The most common example I can think of is hardcoded encryption/obfuscation related keys. But great as it is, it's just one method and is easy for attackers to change.

# Pivot on opcodes
Opcodes are an extremely powerful way to pivot on. But the problem with this is that compiler settings, versions, etc could all potentially change the opcodes because of optimizations and other things, so it's hard to find a valid use case for pivoting on opcodes.

# Pivot on sandbox/emulation results
Some systems come with a sandbox/emulator, and you can pivot off those dynamic results as well. For example, pivoting off a hardcoded mutex name, file name, or registry key would work only when this is being executed. In my opinion if you can get a good system with these kind of capabilities, it would be the most powerful way to pivot most of the time.

# Pivot on file similarity
Some systems have their own tagging capability on what a particular executable can do. A simple example would be to tag whether the executable has anti-debugging capabilities. By tagging on hundreds or thousands of such capabilities, the system can match on other executables with similar tags.

# Pivot on filename
If we get something called install.exe or svchost.exe, there will be many matches, but otherwise filenames can be surprisingly unique.
Something to note about filenames is that VTI can search by filenames in zip files as well, via "metadata:<filename>". This works for sub-folders in the zip as well and worked even for a few random non-executable filetypes/extensions as well.

# Pivot on nonexistence
Remember that pivoting is just as much matching using data that is there (e.g. export name = x) as it is matching using data that is **not** there (e.g. export name != y, import name != z).

# Pivot on Infrastructure
Even different kinds of malware families might use the same infrastructure. Of course, this assumes that the C2 server has not been hacked by another actor.

# Pivot on different formats
If you have a particular string, you might make a duplicate rule which searches for that string in a different format such as base64. This helps to pivot in some edge cases, such as when the file you are looking for is not in its original format (e.g. a script decodes it or it is embedded in another file type).

# Pivot on exploit code
For finding the source document (rather than malware exes), malware writers will have some have coded ASM related to the exploit (especially since this is hand-coded/automated it theoretically will not change as often)

# Pivot on original/unpacked file
The malware author or a researcher might upload the original unobfuscated/unpacked file.

# Pivot on SSDeep
SSDeep is not very useful for EXEs, but for document pivoting it works very well.

# Pivot on relationship
Certain files have relations with each other. For example, a zip might have a relationship with an email, a doc might have a relationship with a zip, and an OLE might have a relationship with a doc. Depending on the file type (and your luck), VTI or other kinds of systems may store these relationships, so you can e.g. pivot on OLE to find another OLE which can lead you to a new doc.

# Pivot on country submitter + certain characteristics
Especially if a country is not exceptionally large, we can use VTI dorks to track uploads from a certain country which has certain characteristics.
It will be a waste of time if we only track characteristics which are not very rare, but if we combine this together with the submitter country, we can actually "threat hunt" globally.
In fact this is not limited to country submitter - we can find any kinds of unique characterstics and once we have enough data, cluster them into attack groups.

Once related samples are found (and false positives / similar author but different malware etc) are weeded out, remember that this is a recursive process. Find new samples? Check if there's more data on which you can continue your hunt on and again.
Remember that you can pivot on your pivot first as well. E.g. https://twitter.com/kyleehmke/status/1154826875203661824 --- pivoting on domains to find more domains.
